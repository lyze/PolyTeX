<!-- @license  -->
<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">

<link rel="import" href="../gtex-code-textarea/gtex-code-textarea.html">

<dom-module id="gtex-cloud-editor">
  <style>
  </style>
  <script src="//cdnjs.cloudflare.com/ajax/libs/codemirror/5.14.2/mode/stex/stex.js"></script>
  <template>
    <gtex-code-textarea id="editor" class="flex" editor-options="{{editorOptions}}" animated="true"></gtex-code-textarea>
    <google-client-loader id="driveApiLoader" name="drive" version="v3"></google-client-loader>
    <google-realtime-api id="realtimeApiLoader"></google-realtime-api>
  </template>
</dom-module>
<script src="googleapis.js"></script>
<script>
  Polymer({
    is: 'gtex-cloud-editor',

    /**
     * Fired when the Google APIs are loaded.
     * @event cloud-ready
     */

    /**
     * Fired when the Google Drive file is created/found.
     * @event cloud-file-loaded
     */

    properties: {
      editorOptions: {
        type: Object,
        notify: true,
      },

      noCloud: Boolean,

      cloudStatus: {
        type: String,
        readOnly: true,
        notify: true,
      },

      fileId: {
        type: String,
        readOnly: true,
        notify: true
      },
      name: {
        type: String,
        notify: true
      },
      webViewLink: {
        type: String,
        readOnly: true,
        notify: true
      }
    },

    listeners: {
      'name-changed': 'nameChanged',
    },


    getValue: function () {
      return this.$.editor.getValue();
    },

    setValue: function (v) {
      return this.$.editor.setValue(v);
    },

    created: function () {
      console.log('Loading Google APIs...');
    },

    // Google API Integration

    _initGoogle: function () {
      var realtimePromise;
      if (this.$.realtimeApiLoader.libraryLoaded) {
        realtimePromise = Promise.resolve(realtimeApiLoader.api);
      } else {
        realtimePromise = new Promise((resolve, reject) => {
          this.$.realtimeApiLoader.addEventListener('api-load', e =>
            resolve(new Realtime(e.target.api), new Auth(window.gapi.auth)));

          // TODO: consider UX for case when realtime is unavailable
          this.$.realtimeApiLoader.addEventListener(
            'library-error-message-changed', e => reject(e.detail.value));
        });
      }

      var drivePromise = new Promise((resolve, reject) => {
        this.$.driveApiLoader.addEventListener('google-api-load', e =>
          Auth._authorize(e.target.auth, _ =>
            resolve(new Drive(e.target.api, window.gapi))));

        this.$.driveApiLoader.addEventListener(
          'google-api-load-error',
          e => {
            reject(e.detail.value);
            this._setCloudStatus('unavailable');
        });
      });

      Promise.all([drivePromise, realtimePromise]).then(([drive, realtime]) => {
        console.log('Loaded Google APIs.')
        this.drive = drive;
        this.realtime = realtime;
        this._setCloudStatus('ready-to-connect');
        this.fire('cloud-ready');
      });
    },

    ready: function () {
      if (this.noCloud) {
        this._setCloudStatus('unavailable');
      } else {
        this._initGoogle();
      }
    },

    checkCloud: function () {
      if (this.noCloud) {
        throw new Error('Cloud support not available.');
      }
    },

    startDriveIntegration: function () {
      this.checkCloud();

      var initializeModel = model => {
        console.log('Initializing model...');
        var string = model.createString();
        string.setText('');
        model.getRoot().set('PolyTeX-data', string);
      };

      var wire = doc => {
        console.log('Enabling realtime in components...');
        var model = doc.getModel();
        var collaborativeString = model.getRoot().get('PolyTeX-data');
        var codeMirror = this.$.editor.codeMirror;
        var codeMirrorDoc = codeMirror.getDoc();
        collaborativeString.addEventListener(
          this.realtime.api.EventType.TEXT_INSERTED, e => {
            var pos = codeMirrorDoc.posFromIndex(e.index);
            // performs an insertion if you call it with only one position argument
            doc.replaceRange(e.text, pos);
        });
        collaborativeString.addEventListener(
          this.realtime.api.EventType.TEXT_DELETED, e => {
            var start = codeMirrorDoc.posFromIndex(e.index);
            var end = codeMirrorDoc.posFromIndex(e.index + e.text.length);
            doc.replaceRange('', start, end);
        });
        codeMirror.on('change', (_, e) => {
          if (this.fileId) {
            this._setCloudStatus('dirty');
          }
          model.beginCompoundOperation();
          for (let line = e.from.line; line < e.to.line; line++) {
            var start = codeMirrorDoc.indexFromPos({line: line, ch: e.from.ch});
            var end = codeMirrorDoc.indexFromPos({line: line, ch: e.to.ch});
            collaborativeString.removeRange(start, end);
            collaborativeString.insertString(start, e.text[line - e.from.line]);
          }
          model.endCompoundOperation();
        });
      };

      this._setCloudStatus('saving');
      this.drive.createTeXFile(this.name, {fields: 'id,name,webViewLink,createdTime'}).then(response => {
        this.fire('cloud-file-loaded', response);

        console.log('Created Google Drive file: ' + response.result.name, response);

        this._setFileId(response.result.id);
        this._setWebViewLink(response.result.webViewLink);

        this.save();

        // start the realtime functionality
        // TODO: realtime can be orthogonal from saving to drive
        console.log('Connecting realtime API...');
        this.realtime.load(response.result.id, wire, initializeModel,
                           e => app.apiErrorMessage = e.toString());
      });
    },

    save: function () {
      this.checkCloud();

      this._setCloudStatus('saving');

      // XXX use the realtime model data instead?
      return this.drive.saveTeXFile(this.fileId, this.getValue()).then(response => {
        if (this.cloudStatus === 'saving') {
          // did not become dirty after beginning save
          this._setCloudStatus('saved');
        }
        console.log('Saved.', response);
        return response;
      }, response => {
        this._setCloudStatus('dirty');
        console.error('Cannot save file.', response);
        throw response;
      });
    },

    nameChanged: function (newName) {
      if (this.noCloud) {
        return;
      }
      // TODO: filename change
      console.log(`New name: ${newName}`);
    },



  });
</script>
