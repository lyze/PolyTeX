<!-- @license  -->
<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">

<link rel="import" href="../gtex-code-textarea/gtex-code-textarea.html">

<dom-module id="gtex-cloud-editor">
  <style>
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.14.2/mode/stex/stex.js"></script>
  <template>
    <gtex-code-textarea id="editor" class="flex" editor-options="{{editorOptions}}" animated="true"></gtex-code-textarea>
    <google-client-loader id="driveApiLoader" name="drive" version="v3"></google-client-loader>
    <google-realtime-api id="realtimeApiLoader"></google-realtime-api>
  </template>
</dom-module>
<script src="googleapis.js"></script>
<script>
  Polymer({
    is: 'gtex-cloud-editor',

    /**
     * Fired when the Google APIs are loaded.
     * @event cloud-ready
     */

    /**
     * Fired when the Google Drive file is created/found.
     * @event cloud-file-loaded
     */

    properties: {
      editorOptions: {
        type: Object,
        notify: true,
      },

      noCloud: Boolean,

      name: {
        type: String,
        readOnly: true,
        notify: true
      },

      cloudStatus: {
        type: String,
        readOnly: true,
        notify: true,
      },


      /**
       * The ID of the file. If changed, will attempt to load the new file.
       */
      fileId: {
        type: String,
        notify: true
      },

      /**
       * A link to view the file.
       */
      webViewLink: {
        type: String,
        readOnly: true,
        notify: true
      },

      /**
       * The last modified time in Drive.
       */
      lastCloudModifiedTime: {
        type: Date,
        readOnly: true,
        notify: true
      },

      /**
       * The error message from the API.
       */
      apiError: {
        type: Object,
        readOnly: true,
        notify: true
      },
    },

    listeners: {
      'file-id-changed': '_fileIdChanged',
    },


    getValue: function () {
      return this.$.editor.getValue();
    },

    setValue: function (v) {
      return this.$.editor.setValue(v);
    },

    created: function () {
    },

    // Google API Integration
    // TODO: Consider using gapi.auth2 to handle multiple logins more easily.

    connectCloud() {
      return this._initialized.catch(_ => {
        console.log('Authorizing Google APIs (popup)...');
        return this.auth.authorize().then(token => {
          this._setCloudStatus('ready-to-sync');
          return token;
        }, token => {
          console.error('Authorization failed.', token);
          this._setCloudStatus('unauthorized');
          this._setApiError();
          this._setApiError('Authorization failed.');
          throw token;
        });
      });
    },

    _tryConnectGoogleSilentlyOrDie: function () {
      if (this._immediateLoginFailed) {
        console.log('Not attempting to authorize Google APIs silently because of a previous failed attempt.');
        return Promise.reject(this._immediateLoginFailed);
      }

      this._setCloudStatus('authorizing');
      console.log('Authorizing Google APIs silently...');

      return this.auth.authorizeImmediate().then(token => {
        console.log('Authorized silently.', token);
        this._setCloudStatus('ready-to-sync');
        this.fire('cloud-ready');
      }, token => {
        this._immediateLoginFailed = token;
        throw token;
      });
    },

    _initGoogle: function () {
      console.log('Loading Google APIs...');
      var realtimePromise;
      if (this.$.realtimeApiLoader.libraryLoaded) {
        realtimePromise = Promise.resolve(realtimeApiLoader.api);
      } else {
        realtimePromise = new Promise((resolve, reject) => {
          this.$.realtimeApiLoader.addEventListener('api-load', e => {
            resolve(new Realtime(e.target.api, new Auth(this._gapi.auth)));
          });

          // TODO: consider UX for case when realtime is unavailable
          this.$.realtimeApiLoader.addEventListener(
            'library-error-message-changed', e => { // TODO: fire event
              this._setCloudStatus('unavailable');
              console.error('Failed to load Realtime API.', e);
              reject(e.detail.value);
          });
        });
      }

      var drivePromise = new Promise((resolve, reject) => {
        this.$.driveApiLoader.addEventListener('google-api-load', e => {
          resolve(new Drive(e.target.api, this._gapi));
        });

        this.$.driveApiLoader.addEventListener(
          'google-api-load-error', e => { // TODO: fire event
            this._setCloudStatus('unavailable');
            console.error('Failed to load Drive API.', e);
            reject(e.detail.value);
        });
      });

      return Promise.all([drivePromise, realtimePromise]).then(([drive, realtime]) => {
        console.log('Loaded Google APIs.')
        this.drive = drive;
        this.realtime = realtime;
        this.auth = new Auth(this._gapi.auth);

        var p = this._tryConnectGoogleSilentlyOrDie();
        p.catch(token => {
          console.log('Failed to authorize silently. A login is required.',
                      token);
          this._setCloudStatus('unauthorized');
        });
        return p;
      });
    },

    ready: function () {
      if (this.noCloud) {
        this._setCloudStatus('unavailable');
      } else {
        this._initialized = this._initGoogle();
      }
    },

    checkCloud: function () {
      if (this.noCloud) {
        throw new Error('Cloud support is not available.');
      }
      if (this.cloudStatus === 'unavailable') {
        throw new Error('Google API is not loaded.');
      }
      if (this.cloudStatus === 'unauthorized') {
        this._setApiError('Google Drive API is not authorized.');
        throw new Error('Google Drive API is not authorized.');
      }
    },

    get _gapi () {
      console.assert(window.gapi, 'window.gapi should exist');
      return window.gapi;
    },

    endCloudIntegration: function () {
      this.checkCloud();

      this._collaborativeString.removeEventListener(
        this.realtime.api.EventType.TEXT_INSERTED,
        this._realtimeCollaborativeInsertionListener);

      this._collaborativeString.removeEventListener(
        this.realtime.api.EventType.TEXT_DELETED,
        this._realtimeCollaborativeDeletionListener);

      this.$.editor.codeMirror.off('change', this._realtimeCodeMirrorListener);

      console.log('Signing out...');
      this._gapi.auth.signOut();
      console.log('Signed out.');

      this._setCloudStatus('unauthorized');
      this._setFileId(null);
      this._setWebViewLink(null);
      this._immediateLoginFailed = null;
    },

    _resetRealtime: function () {
      if (this._realtimeDocument) {
        this._realtimeDocument.close();
      }
      this.$.editor.codeMirror.off('change', this._realtimeCodeMirrorListener);
    },

    _loadRealtime: function () {
      console.log('Connecting realtime API...');
      // TODO: realtime can be orthogonal from saving to drive
      const initializeModel = model => {
        console.log('Initializing model...');
        var string = model.createString();
        string.setText('');
        model.getRoot().set('PolyTeX-data', string);
      };

      const _realtimeOnLoaded = doc => {
        console.log('Loading realtime for editor components...');
        this._realtimeDocument = doc;
        var model = doc.getModel();
        var collaborativeString = model.getRoot().get('PolyTeX-data');
        this._collaborativeString = collaborativeString;
        var codeMirror = this.$.editor.codeMirror;
        var codeMirrorDoc = codeMirror.getDoc();

        this._realtimeCollaborativeInsertionListener = e => {
          var pos = codeMirrorDoc.posFromIndex(e.index);
          // performs an insertion if you call it with only one position argument
          doc.replaceRange(e.text, pos);
        };
        collaborativeString.addEventListener(
          this.realtime.api.EventType.TEXT_INSERTED,
          this._realtimeCollaborativeInsertionListener);

        this._realtimeCollaborativeDeletionListener = e => {
          var start = codeMirrorDoc.posFromIndex(e.index);
          var end = codeMirrorDoc.posFromIndex(e.index + e.text.length);
          doc.replaceRange('', start, end);
        };
        collaborativeString.addEventListener(
          this.realtime.api.EventType.TEXT_DELETED,
          this._realtimeCollaborativeDeletionListener);

        this._realtimeCodeMirrorListener = (_, e) => {
          if (this.fileId) {
            this._setCloudStatus('dirty');
          }
          model.beginCompoundOperation();
          for (let line = e.from.line; line < e.to.line; line++) {
            var start = codeMirrorDoc.indexFromPos({line: line, ch: e.from.ch});
            var end = codeMirrorDoc.indexFromPos({line: line, ch: e.to.ch});
            collaborativeString.removeRange(start, end);
            collaborativeString.insertString(start, e.text[line - e.from.line]);
          }
          model.endCompoundOperation();
        };
        codeMirror.on('change', this._realtimeCodeMirrorListener);
        console.log('Loaded realtime components.');
      };

      this.realtime.load(this.fileId, _realtimeOnLoaded, initializeModel, e => {
        this._setApiError(e);
      }, e => {
        this._setApiError('Failed to reauthorize for Google services.');
      });
    },

    _createNewCloudFile: function () {

      this._setCloudStatus('saving');
      return this.drive.createTeXFile(this.name, {fields: 'id,name,webViewLink,createdTime'}).then(response => {
        console.log('Created Google Drive file: ' + response.result.name, response);

        this._setFileId(response.result.id);
        this._setWebViewLink(response.result.webViewLink);
        this.fire('cloud-file-loaded', response);

        this.save();


        this._loadRealtime();

      }, errorResponse => {
        this._setApiError(errorResponse.result.error.message);
      });
    },


    _findCloudFile: function () {
      this._setCloudStatus('loading-file')
      return this.drive.loadFile(this.fileId, {fields: 'id,name,webViewLink,modifiedTime,capabilities'}).then(([metadataResponse, downloadResponse]) => {
        console.log('Retrieved drive file metadata.', metadataResponse);
        console.log('Retrieved drive file content.', downloadResponse);
        console.assert(this.fileId === metadataResponse.result.id,
                       'Drive API file ID response should be the same as requested');
        // if the assertion fails, then the file ID change event triggers again
        this.fileId = metadataResponse.result.id;
        this._setName(metadataResponse.result.name);
        this._setWebViewLink(metadataResponse.result.webViewLink);
        this._setLastCloudModifiedTime(new Date(metadataResponse.result.modifiedTime));
        this._cloudEditable = metadataResponse.result.capabilities.canEdit;

        this.$.editor.setValue(downloadResponse.body);

        if (this._cloudEditable) {
          this._loadRealtime(); // not blocking but notify 'loaded' regardless
          this._setCloudStatus('loaded');
          this.fire('cloud-file-loaded', metadataResponse);
        } else {
          this._setCloudStatus('loaded-read-only');
        }
      }, errorResponse => {
        this._setApiError(errorResponse.result.error.message);
      });
    },


    startCloudIntegration: function () {
      return this.connectCloud().then(_ => {
        this._resetRealtime();
        return this.fileId ? this._findCloudFile() : this._createNewCloudFile();
      });
    },


    save: function () {
      this.checkCloud();

      this._setCloudStatus('saving');

      // XXX use the realtime model data instead?
      return this.drive.saveTeXFile(this.fileId, this.getValue()).then(response => {
        if (this.cloudStatus === 'saving') {
          // did not become dirty after beginning save
          this._setCloudStatus('saved');
        }
        // otherwise, it became dirty while saving, so don't update the status
        console.log('Saved.', response);
        return response;
      }, response => {
        if (this.fileId) {
          this._setCloudStatus('dirty');
        }
        console.error('Cannot save file.', response);
        this._setApiError(response.error.message);
        throw response;
      });
    },


    rename: function (newName) {
      if (this.noCloud) {
        return;
      }
      // TODO UI for (un)successful rename?
      this.drive.renameFile(this.fileId, newName, {fields: 'modifiedTime'}).then(response => {
        console.log('File renamed.', response);
        this._setLastCloudModifiedTime(new Date(response.result.modifiedTime));
      });
    },


    _fileIdChanged: function (e) {
      if (this.noCloud) {
        return;
      }
      var newId = e.detail.value;
      this._initialized.then(_ => {
        console.log('id', this.fileId);
        this.startCloudIntegration();
      }).catch(e => {
        if (this.cloudStatus === 'unauthorized' && this.fileId) {
          this._setApiError('Connect with Drive to view the file.');
        } else {
          throw e;
        }
      });
    },

  });
</script>
